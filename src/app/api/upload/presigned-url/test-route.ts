import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';

// Validation schema for request body
const UploadRequestSchema = z.object({
  fileName: z.string().min(1, 'File name is required').max(255, 'File name too long'),
  fileType: z.string().min(1, 'File type is required'),
  fileSize: z.number().positive('File size must be positive').max(100 * 1024 * 1024, 'File size too large (max 100MB)'),
  folder: z.string().optional().default('uploads'),
});

// Validate file type
const isValidFileType = (fileType: string) => {
  const allowedTypes = [
    'image/jpeg',
    'image/png', 
    'image/gif',
    'image/webp',
    'application/pdf',
    'text/plain',
    'application/json',
    'video/mp4',
    'video/webm',
    'audio/mpeg',
    'audio/wav',
  ];
  
  return allowedTypes.includes(fileType);
};

// Generate unique file key
const generateFileKey = (fileName: string, folder: string) => {
  const timestamp = Date.now();
  const randomString = Math.random().toString(36).substring(2, 15);
  const sanitizedFileName = fileName.replace(/[^a-zA-Z0-9.-]/g, '_');
  return `${folder}/${timestamp}-${randomString}-${sanitizedFileName}`;
};

export async function POST(request: NextRequest) {
  try {
    // Parse and validate request body
    const body = await request.json();
    const validatedData = UploadRequestSchema.parse(body);
    
    const { fileName, fileType, folder } = validatedData;
    
    // Additional file type validation
    if (!isValidFileType(fileType)) {
      return NextResponse.json(
        { 
          error: 'Invalid file type. Allowed types: images, PDF, text, JSON, video, audio' 
        },
        { status: 400 }
      );
    }
    
    // Generate unique file key
    const fileKey = generateFileKey(fileName, folder);
    
    // Mock presigned URL for testing (in real implementation, this would be generated by AWS SDK)
    const mockPresignedUrl = `https://${process.env.AWS_S3_BUCKET_NAME || 'test-bucket'}.s3.${process.env.AWS_REGION || 'us-east-1'}.amazonaws.com/${fileKey}?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=test%2F20240101%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20240101T000000Z&X-Amz-Expires=900&X-Amz-SignedHeaders=host&X-Amz-Signature=test-signature`;
    
    // Return success response
    return NextResponse.json({
      success: true,
      data: {
        presignedUrl: mockPresignedUrl,
        fileKey,
        expiresIn: 900,
        uploadUrl: mockPresignedUrl,
        fields: {
          key: fileKey,
          'Content-Type': fileType,
        },
        // Add test indicator
        testMode: true,
        message: 'This is a test response. In production, you would get a real presigned URL from AWS.'
      },
    });
    
  } catch (error) {
    console.error('Error generating presigned URL:', error);
    
    // Handle validation errors
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { 
          error: 'Validation failed',
          details: error.issues.map((err: z.ZodIssue) => ({
            field: err.path.join('.'),
            message: err.message,
          })),
        },
        { status: 400 }
      );
    }
    
    // Generic error
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

// Handle unsupported methods
export async function GET() {
  return NextResponse.json(
    { error: 'Method not allowed. Use POST to generate presigned URLs.' },
    { status: 405 }
  );
}
